<!-- omit in toc -->
# Lab 5: Cache simulator (direct mapping and fully associative)

Caches are implemented in computing systems because they mitigate the lengthy time that it takes to retrieve data from memory. This serves as the primary motivation for this lab, which is a cache simulator that implements the cache direct mapping (DM) and fully associative (FA) cache mapping algorithms.

To simplify the lab, some parameters are much smaller than they would be in practice. In particular, this simulator uses a cache with 8 cache lines, and the physical memory has 256 addresses (i.e., each address is 8 bits), each of which stores a byte.

For more specifics, see the hardcoded values in [constants.h](constants.h).

While you write code, keeping these concrete values in mind may help with understanding. However, you should not use these hardcoded literals in your code because some test cases use different values from the hardcoded ones. So, you must use the symbolic variable names, such as `num_addr_bits` and `num_block_offset_bits`, and do not hardcode int literal values.

<details open>
<summary>Contents</summary>

- [Background reading](#background-reading)
  - [Repo structure](#repo-structure)
- [Input/output](#inputoutput)
  - [Running the main executable](#running-the-main-executable)
  - [Explanation of input/output](#explanation-of-inputoutput)
- [Understand given code](#understand-given-code)
- [Coding tips](#coding-tips)
  - [copy\_phy\_memory\_block\_to\_cache\_line](#copy_phy_memory_block_to_cache_line)
  - [cache\_read](#cache_read)
    - [DM](#dm)
    - [FA](#fa)
- [Submit your assignment](#submit-your-assignment)

</details>

## Background reading

This lab is aligned very closely with the lecture content on caches and cache mapping algorithms. You must fully understand the relevant lecture content before proceeding with the lab.

1. (Required) [System concepts, Main Memory and Memory Hierarchy](https://uncch.instructure.com/users/9947/files/5587554?verifier=5pVYCbHJeS551teiKVw1IJezkRZ2uGCeTdpQ1bdu&wrap=1) pgs. 19-23
2. (Required) [Cache Memory, Mapping Algorithms, and the Principle of Locality](https://uncch.instructure.com/users/9947/files/5661387?verifier=FLrrKMVo00veF13U7m7Newwf4c52dBHJB4FWz7iq&wrap=1) pgs. 1-28
    - Highly invaluable for implementing the DM and FA cache mapping algorithms.
    - Contains concrete and easily understandable examples of DM and FA.
    - If you don't understand this content, this repo's code and structure may not make sense to you.

### Repo structure

```text
> tree . -I "googletest|ag_lib" --charset=ascii
.
|-- cache.c - Important functions to implement
|-- cache.h
|-- constants.h - Important, a few hardcoded values for the simulation
|-- data - Important
|   |-- dm_in0.txt - Input for main function in dm mode
|   |-- dm_in1.txt - Output for main function in dm mode
|   |-- ...
|   `-- memory.txt - Hardcoded physical memory values
|-- main.cpp - Runs the simulation
|-- Makefile - Generates two executables, main and tests
|-- memory.c - Important, one function to implement, and you should understand the others
|-- memory.h
|-- README.md
|-- tests.cpp
|-- tests.hpp
|-- types.h - Important custom types you must understand
|-- utils.cpp - Mostly unimportant, helper functions for the simulator. It may be useful to understand the sim function
`-- utils.hpp
```

Similar to the previous lab, you must understand the files marked "important".

## Input/output

To show you what the simulator does at a high level, example inputs and outputs are in [data/](data). Specifically, consider the three files [data/memory.txt](data/memory.txt), [data/dm_in0.txt](data/dm_in0.txt) and [data/dm_out0.txt](data/dm_out0.txt).

### Running the main executable

The `out` file was generated by compiling with `make` and running `./main data/memory.txt dm < data/dm_in0.txt > data/dm_out0.txt`.

`data/memory.txt` looks like

```text
7F
24
7A
...
```

It's just a list of 256 hex values that each represent a byte of physical memory.

"dm" tells the simulator to use the direct mapping mode. Alternatively, it could be "fa".

The `memory_file` and `dm|fa` are required arguments for `main`.

### Explanation of input/output

In `data/dm_out0.txt`, there are some lines like

```text
Enter 8-bit memory address in hex format or "exit" to exit: 0x
```

The inputted value is missing because the command that generates the file redirects only `stdout` to the file, but the inputted values are read from `stdin`, not `stdout`. But, if the program is run interactively in the terminal, we'll see the inputted values interspersed with the output. Here's the expected output when running in `dm` mode and inputting hex memory addresses `0`, `1`, `10`, and `20`, a subset of values from `data/dm_in0.txt`:

```text
learncli$ ./main data/memory.txt dm
Physical memory address number of bits: 8
Number of blocks: 64

Enter 8-bit memory address in hex format or "exit" to exit: 0x0

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x0 | 1     | 0x7f | 0x24 | 0x7a | 0x41 |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache miss, value 0x7f from address 0x0 was copied into cache (along with the rest of the block)
No replacement, a cache line that was not in-use is now in-use

Enter 8-bit memory address in hex format or "exit" to exit: 0x1

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x0 | 2     | 0x7f | 0x24 | 0x7a | 0x41 |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache hit, retrieved value 0x24, which is also at address 0x1
Enter 8-bit memory address in hex format or "exit" to exit: 0x10

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x0 | 2     | 0x7f | 0x24 | 0x7a | 0x41 |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | y       | 0x0 | 1     | 0x68 | 0x7f | 0x7f | 0x60 |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache miss, value 0x68 from address 0x10 was copied into cache (along with the rest of the block)
No replacement, a cache line that was not in-use is now in-use

Enter 8-bit memory address in hex format or "exit" to exit: 0x20

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x1 | 1     | 0x7f | 0x7f | 0x7f | 0x4f |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | y       | 0x0 | 1     | 0x68 | 0x7f | 0x7f | 0x60 |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache miss, value 0x7f from address 0x20 was copied into cache (along with the rest of the block)
Replacement, an in-use cache line was evicted

Enter 8-bit memory address in hex format or "exit" to exit: 0xexit
```

Notice that the tables are essentially identical to the tables in the cache mapping algorithm slides. The only small difference is that we rename the "valid" column name to "present". Also, the column "b" represents "Block offset" like the lecture slides but has to be abbreviated to maintain consistent column widths. If you haven't looked at these [lecture slides](#background-reading) yet, they're very relevant, so you should do so now!

If you understand the slides, you'll understand what's going on in the example above. Four cache reads are performed, and after each read, the state of the cache is printed along with information about the read operation. The simulator prints whether there is a cache hit or miss. If there was a miss, then data from memory is copied into the cache. In that case, the simulator also prints whether the data was copied into an open cache line or an existing line was evicted and replaced with new data.

Hopefully, this high-level description of input/output helps you understand your coding task.

Similar to the previous lab, your `main` executable won't generate correct output until you're done with the final function, `cache_read`. But, `tests.cpp` unit tests each helper function so that you'll get immediate feedback as you code.

## Understand given code

If you haven't already, skim through the files marked "important" in [Repo structure](#repo-structure).

[types.h](types.h) is particularly important to understand. Similar to the previous lab, if you understand the types and the [example above](#explanation-of-inputoutput), the code you'll have to write should become much more clear.

You will implement the functions in the order that they are tested in [tests.cpp](tests.cpp), so it may be useful to skim functions in that order. However, note that it will be useful to understand some non-tested and already complete functions, such as [memory.c#determine_block_locations](memory.c).

Finally, note that some functions have a lot of parameters. For example, the `cache_read` function signature is

```c
cache_read_rv cache_read(cache* cache, unsigned int addr,
                         cache_mapping_algo cma,
                         simulation_parameters sim_params,
                         unsigned int* block_locations,
                         unsigned int* phy_memory)
```

This may seem like a lot to keep track of. However, all parameters are necessary, so the only alternative is to use global variables. However, global variables are bad practice because for a given function, you wouldn't be able to easily figure out which global variables to use or not use, so there would actually be more mental overhead. In general, for all functions in this lab, all necessary information to implement the function correctly is passed as parameters. So, within any function, you need only keep track of the parameters and no other information (i.e., no global variables that would possibly be in different files). Lastly, for `cache_read` in particular, several of the parameters are simply trivially passed to other helper functions, so you don't need to keep all parameters in mind at the same time.

## Coding tips

`cache_read` is the most difficult function because you'll have to implement the DM and FA cache mapping algorithms (detailed examples of the algorithms are given in [lecture slides](#background-reading) and also explained [below](#cache_read)). All other functions are helper functions for `cache_read` that should be relatively straightforward.

**Implement the functions in the order they are tested in [tests.cpp](tests.cpp)**.

Please read the header file docstrings, implementation file comments, test cases, and [data files](data/) carefully. All provide necessary information for implementation.

Here is some additional information that may be helpful.

### copy_phy_memory_block_to_cache_line

The functionality of `copy_phy_memory_block_to_cache_line` is identical to the sections highlighted yellow ("Put copy of block... in cache") in the lecture slides that show DM or FA examples. This function works the same way in both DM and FA.

![copy_phy_memory_block_to_cache_line](https://i.imgur.com/Q2s1xVQ.png)

### cache_read

As mentioned above, this function is the most difficult one. However, you've already implemented a lot of the necessary functionality in the previous helper functions and now need only implement the core of the DM and FA algorithms and call the helper functions when necessary.

Hopefully, you already have a decent understanding of the DM and FA algorithms from the detailed examples in the [lecture slides](#background-reading). But, we'll also describe the two algorithms at a high level here. We intentionally omit some details so that you can figure them out. For example, maybe we'll say whether a certain situation is a cache hit or miss, but you need to decide what to do on a hit or miss. All necessary details are in the lecture slides and the `cache_read` docstring.

Note that this function is tested simply by running the `main` function on the input [data](data) files and comparing its output to the expected output files. See the docstring in [tests.cpp](tests.cpp)'s `CacheReadDM` test case for more details. So, to debug your code, you can compile and run your main executable on a given input and compare the output to the expected output.

#### DM

In DM, an address's value can be cached in only one cache line, based on the address's `line` bits.

1. First, check if that cache line is `present`. Assume in the below substeps that it is.
    1. If the cache line's `tag` matches the address's `tag`, it's a cache hit.
    2. Else, it's a cache miss with replacement. This is because a new value (actually, an entire block) needs to go in the same line, but the line is already full. So, you need to evict this cache line.
2. Else, the cache line is not `present`. This is now a cache miss without replacement because the line is not in-use. So, do the same as in the cache miss with replacement case, but `rv.replace` should be `false` (it is `false` by default).
3. Finally, set `rv.value` to be the value in cache (or memory, since they should be the same) corresponding to the requested `addr`.

#### FA

In FA, an address's value can be cached in any cache line, based on the `tag` bits and cache lines' `present` values. It is not the case that a particular address always maps to the same cache line. You have to loop through all lines in the cache.

1. Write a `for` loop that loops over all lines in the cache.
    1. If the current line is present and the `tag` matches, it's a cache hit.
    2. Else, if the current line is not present, it must be a cache miss without replacement. This is because we have already checked condition 1.1, and it is false. So, the value must not be in the cache. If it were, condition 1.1 would have been true because we would have already seen the present cache line with matching tag bits.
    3. Finally, if neither of the above is true and we have reached the final cache line, the cache must be full. This is now a cache miss with replacement, and you must evict the least frequently used (LFU) cache line.
        1. For details regarding the LFU strategy, see the docstring of `cache_read`.
2. Finally, set `rv.value` to be the value in cache (or memory, since they should be the same) corresponding to the requested `addr`.

## Submit your assignment

See the [instructions for assignment submission](https://github.com/Comp211-FA24/lab-00?tab=readme-ov-file#submit-your-assignment).
