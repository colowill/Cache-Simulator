<!-- omit in toc -->
# Lab 5: Cache simulator (direct mapping and fully associative)

Caches are implemented in computing systems because they mitigate the lengthy time that it takes to retrieve data from memory. This serves as the primary motivation for this lab, which is a cache simulator that implements the cache direct mapping (DM) and fully associative (FA) cache mapping algorithms.

To simplify the lab, some parameters are much smaller than they would be in practice. In particular, this simulator uses a cache with 8 cache lines, and the physical memory has 256 addresses (i.e., each address is 8 bits), each of which stores a byte.

### Repo structure

```text
> tree . -I "googletest|ag_lib" --charset=ascii
.
|-- cache.c - Important functions to implement
|-- cache.h
|-- constants.h - Important, a few hardcoded values for the simulation
|-- data - Important
|   |-- dm_in0.txt - Input for main function in dm mode
|   |-- dm_in1.txt - Output for main function in dm mode
|   |-- ...
|   `-- memory.txt - Hardcoded physical memory values
|-- main.cpp - Runs the simulation
|-- Makefile - Generates two executables, main and tests
|-- memory.c - Important, one function to implement, and you should understand the others
|-- memory.h
|-- README.md
|-- tests.cpp
|-- tests.hpp
|-- types.h - Important custom types you must understand
|-- utils.cpp - Mostly unimportant, helper functions for the simulator. It may be useful to understand the sim function
`-- utils.hpp
```

Similar to the previous lab, you must understand the files marked "important".

## Input/output

To show you what the simulator does at a high level, example inputs and outputs are in [data/](data). Specifically, consider the three files [data/memory.txt](data/memory.txt), [data/dm_in0.txt](data/dm_in0.txt) and [data/dm_out0.txt](data/dm_out0.txt).

### Running the main executable

The `out` file was generated by compiling with `make` and running `./main data/memory.txt dm < data/dm_in0.txt > data/dm_out0.txt`.

`data/memory.txt` looks like

```text
7F
24
7A
...
```

It's just a list of 256 hex values that each represent a byte of physical memory.

"dm" tells the simulator to use the direct mapping mode. Alternatively, it could be "fa".

The `memory_file` and `dm|fa` are required arguments for `main`.

### Explanation of input/output

In `data/dm_out0.txt`, there are some lines like

```text
Enter 8-bit memory address in hex format or "exit" to exit: 0x
```

The inputted value is missing because the command that generates the file redirects only `stdout` to the file, but the inputted values are read from `stdin`, not `stdout`. But, if the program is run interactively in the terminal, we'll see the inputted values interspersed with the output. Here's the expected output when running in `dm` mode and inputting hex memory addresses `0`, `1`, `10`, and `20`, a subset of values from `data/dm_in0.txt`:

```text
learncli$ ./main data/memory.txt dm
Physical memory address number of bits: 8
Number of blocks: 64

Enter 8-bit memory address in hex format or "exit" to exit: 0x0

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x0 | 1     | 0x7f | 0x24 | 0x7a | 0x41 |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache miss, value 0x7f from address 0x0 was copied into cache (along with the rest of the block)
No replacement, a cache line that was not in-use is now in-use

Enter 8-bit memory address in hex format or "exit" to exit: 0x1

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x0 | 2     | 0x7f | 0x24 | 0x7a | 0x41 |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache hit, retrieved value 0x24, which is also at address 0x1
Enter 8-bit memory address in hex format or "exit" to exit: 0x10

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x0 | 2     | 0x7f | 0x24 | 0x7a | 0x41 |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | y       | 0x0 | 1     | 0x68 | 0x7f | 0x7f | 0x60 |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache miss, value 0x68 from address 0x10 was copied into cache (along with the rest of the block)
No replacement, a cache line that was not in-use is now in-use

Enter 8-bit memory address in hex format or "exit" to exit: 0x20

+------+---------+-----+-------+------+------+------+------+
|      |         |     |       | b    |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| line | present | tag | #hits | 0    | 1    | 2    | 3    |
+------+---------+-----+-------+------+------+------+------+
| 0    | y       | 0x1 | 1     | 0x7f | 0x7f | 0x7f | 0x4f |
+------+---------+-----+-------+------+------+------+------+
| 1    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 2    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 3    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 4    | y       | 0x0 | 1     | 0x68 | 0x7f | 0x7f | 0x60 |
+------+---------+-----+-------+------+------+------+------+
| 5    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 6    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+
| 7    | n       |     |       |      |      |      |      |
+------+---------+-----+-------+------+------+------+------+

Cache miss, value 0x7f from address 0x20 was copied into cache (along with the rest of the block)
Replacement, an in-use cache line was evicted

Enter 8-bit memory address in hex format or "exit" to exit: 0xexit
```

#### DM

In DM, an address's value can be cached in only one cache line, based on the address's `line` bits.

1. First, check if that cache line is `present`. Assume in the below substeps that it is.
    1. If the cache line's `tag` matches the address's `tag`, it's a cache hit.
    2. Else, it's a cache miss with replacement. This is because a new value (actually, an entire block) needs to go in the same line, but the line is already full. So, you need to evict this cache line.
2. Else, the cache line is not `present`. This is now a cache miss without replacement because the line is not in-use. So, do the same as in the cache miss with replacement case, but `rv.replace` should be `false` (it is `false` by default).
3. Finally, set `rv.value` to be the value in cache (or memory, since they should be the same) corresponding to the requested `addr`.

#### FA

In FA, an address's value can be cached in any cache line, based on the `tag` bits and cache lines' `present` values. It is not the case that a particular address always maps to the same cache line. You have to loop through all lines in the cache.

1. Write a `for` loop that loops over all lines in the cache.
    1. If the current line is present and the `tag` matches, it's a cache hit.
    2. Else, if the current line is not present, it must be a cache miss without replacement. This is because we have already checked condition 1.1, and it is false. So, the value must not be in the cache. If it were, condition 1.1 would have been true because we would have already seen the present cache line with matching tag bits.
    3. Finally, if neither of the above is true and we have reached the final cache line, the cache must be full. This is now a cache miss with replacement, and you must evict the least frequently used (LFU) cache line.
        1. For details regarding the LFU strategy, see the docstring of `cache_read`.
2. Finally, set `rv.value` to be the value in cache (or memory, since they should be the same) corresponding to the requested `addr`.

## Submit your assignment

See the [instructions for assignment submission](https://github.com/Comp211-FA24/lab-00?tab=readme-ov-file#submit-your-assignment).
